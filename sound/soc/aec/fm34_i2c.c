#include <linux/module.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <asm/io.h>
#include <asm/system.h>
#include <asm/uaccess.h>
#include <linux/poll.h>
#include <linux/version.h>
#include <linux/semaphore.h>
#include <linux/mutex.h>
#include <linux/gpio.h>
#include <linux/slab.h>
#include "../tegra/tegra_soc.h"

#define FM34_DEBUG 0

#define DRIVER_NAME	"fm34_i2c"

struct fm34_drvdata {
	int fm34_enable_status;
	int fm34_status;
};

static struct i2c_client *fm34_client;

static const u8 patch_data[][9] = {
	{5, 0xFC, 0xF3, 0x68, 0x64, 0x04, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x00, 0x90, 0x00, 0x1A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x01, 0x82, 0x30, 0x50},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x02, 0x27, 0x90, 0x9F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x03, 0x19, 0x00, 0xA0},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x04, 0x1C, 0x5A, 0xAF},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x05, 0x90, 0x00, 0x1A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x06, 0x80, 0x00, 0x0A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x07, 0x1C, 0x5A, 0xAF},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x08, 0x90, 0x00, 0x0A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x09, 0x19, 0x01, 0x1F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x0A, 0x27, 0x90, 0x5F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x0B, 0x19, 0x01, 0x10},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x0C, 0x1C, 0x58, 0xEF},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x0D, 0x90, 0x00, 0x1A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x0E, 0x80, 0x00, 0x0A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x0F, 0x1C, 0x58, 0xEF},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x10, 0x90, 0x00, 0x0A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x11, 0x82, 0x2D, 0x20},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x12, 0x27, 0x98, 0x5F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x13, 0x19, 0x01, 0x80},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x14, 0x80, 0x50, 0x5A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x15, 0x90, 0x50, 0x3A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x16, 0x80, 0x50, 0x6F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x17, 0x90, 0x50, 0x4F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x18, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x19, 0x19, 0x00, 0x6F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x1A, 0x80, 0x00, 0xAC},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x1B, 0x26, 0x7C, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x1C, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x1D, 0x19, 0x1D, 0x82},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x1E, 0x19, 0x1C, 0xEF},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x1F, 0x80, 0x53, 0x9A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x20, 0x93, 0xE2, 0xAA},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x21, 0x80, 0x4F, 0xBA},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x22, 0x22, 0x7A, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x23, 0x19, 0x02, 0x50},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x24, 0x94, 0x4F, 0xB6},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x25, 0x80, 0x4F, 0x6A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x26, 0x26, 0x7A, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x27, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x28, 0x18, 0x2F, 0x80},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x29, 0x18, 0x2B, 0xCF},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x2A, 0x95, 0x62, 0x06},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x2B, 0x95, 0x61, 0x46},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x2C, 0x40, 0xFA, 0x0A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x2D, 0x40, 0xE5, 0xB0},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x2E, 0x82, 0x30, 0x14},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x2F, 0x27, 0x00, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x30, 0x22, 0x78, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x31, 0x83, 0xFD, 0x44},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x32, 0x26, 0xE2, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x33, 0x19, 0x03, 0x90},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x34, 0x93, 0xFD, 0x4A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x35, 0x83, 0xFD, 0x5A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x36, 0x23, 0xA2, 0x1F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x37, 0x93, 0xFD, 0x5A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x38, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x39, 0x04, 0x00, 0x60},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x3A, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x3B, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x3C, 0x04, 0x00, 0x60},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x3D, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x3E, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x3F, 0x80, 0x7C, 0x31},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x40, 0x40, 0x07, 0xE4},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x41, 0x22, 0xE1, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x42, 0x19, 0x04, 0xC5},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x43, 0x22, 0x79, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x44, 0x19, 0x04, 0xC0},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x45, 0x80, 0x7C, 0x21},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x46, 0x22, 0xE1, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x47, 0x19, 0x04, 0xC5},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x48, 0x22, 0x79, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x49, 0x19, 0x04, 0xC0},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x4A, 0x02, 0x80, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x4B, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x4C, 0x00, 0x00, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x4D, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x4E, 0x18, 0x3F, 0xAF},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x4F, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x50, 0x19, 0x6C, 0xA4},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x51, 0x19, 0x66, 0x7F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x52, 0x47, 0xFF, 0xF4},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x53, 0x22, 0xE0, 0x1F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x54, 0x0A, 0x00, 0x04},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x55, 0x0D, 0x00, 0x0A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x56, 0x62, 0x00, 0xC5},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x57, 0x0E, 0x64, 0x0F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x58, 0x2E, 0x7C, 0x59},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x59, 0x22, 0x18, 0xD4},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x5A, 0x2E, 0x69, 0xFA},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x5B, 0x0D, 0x00, 0x91},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x5C, 0x0E, 0x24, 0x03},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x5D, 0x78, 0x00, 0xF9},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x5E, 0x19, 0x05, 0x3F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x5F, 0x0D, 0x00, 0x1A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x60, 0x40, 0x20, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x61, 0x1D, 0x05, 0x2F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x62, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x63, 0x19, 0x30, 0x4F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x64, 0x0D, 0x00, 0x1A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x65, 0x40, 0x20, 0x00},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x66, 0x1D, 0x05, 0x2F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x67, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x68, 0x19, 0x42, 0x2F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x69, 0x80, 0x79, 0xCA},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x6A, 0x82, 0x2D, 0x2F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x6B, 0x27, 0x97, 0x9F},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x6C, 0x19, 0x06, 0xF0},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x6D, 0x94, 0x7B, 0xD6},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x6E, 0x80, 0x00, 0x1A},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x6F, 0x34, 0x00, 0x0E},
	{8, 0xFC, 0xF3, 0x0D, 0x10, 0x70, 0x18, 0x48, 0xDF},
	{5, 0xFC, 0xF3, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA0, 0x90, 0x05, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB0, 0x50, 0x00, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA1, 0x91, 0xCB, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB1, 0x50, 0x1A, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA2, 0x82, 0xF3, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB2, 0x02, 0xF5, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA3, 0x82, 0xB5, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB3, 0x50, 0x1F, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA4, 0x83, 0xF4, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB4, 0x50, 0x2A, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA5, 0x96, 0x66, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB5, 0x50, 0x4F, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA6, 0x93, 0x01, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB6, 0x50, 0x5F, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA7, 0x94, 0x1F, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB7, 0x50, 0x64, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xA8, 0x84, 0x8C, 0x00},
	{7, 0xFC, 0xF3, 0x3B, 0x3F, 0xB8, 0x50, 0x69, 0x00},
};

static int fm34_register_read(struct i2c_client *client, u16 addr, u16 *pval)
{
	struct i2c_msg msg[5];
	u8 CmdBuf0[] = {0xFC, 0xF3, 0x37, 0xFF, 0xFF};
	u8 CmdBuf1[] = {0xFC, 0xF3, 0x60, 0x25};
	u8 CmdBuf2[] = {0xFC, 0xF3, 0x60, 0x26};
	u8 DataLow, DataHigh;

	CmdBuf0[3] = (addr & 0xFF00) >> 8;
	CmdBuf0[4] = addr & 0xFF;

	msg[0].addr = client->addr;
	msg[0].flags = client->flags & I2C_M_TEN;
	msg[0].len = sizeof(CmdBuf0);
	msg[0].buf = CmdBuf0;

	msg[1].addr = client->addr;
	msg[1].flags = client->flags & I2C_M_TEN;
	msg[1].len = sizeof(CmdBuf1);
	msg[1].buf = CmdBuf1;

	msg[2].addr = client->addr;
	msg[2].flags = client->flags & I2C_M_TEN;
	msg[2].flags |= I2C_M_RD;
	msg[2].len = sizeof(DataLow);
	msg[2].buf = &DataLow;

	msg[3].addr = client->addr;
	msg[3].flags = client->flags & I2C_M_TEN;
	msg[3].len = sizeof(CmdBuf2);
	msg[3].buf = CmdBuf2;

	msg[4].addr = client->addr;
	msg[4].flags = client->flags & I2C_M_TEN;
	msg[4].flags |= I2C_M_RD;
	msg[4].len = sizeof(DataHigh);
	msg[4].buf = &DataHigh;

	if(5 != i2c_transfer(client->adapter, msg, 5))
		return -1;

	if(pval)
		*pval = ((DataHigh << 8) | DataLow);

	#if FM34_DEBUG
	printk(KERN_DEBUG "ReadFM34Register Addr:0x%02X%02X Data:0x%02X%02X successful\n", CmdBuf0[3], CmdBuf0[4], DataHigh, DataLow);
	#endif
	return 0;
}

static int fm34_register_write(struct i2c_client *client, u16 addr, u16 value)
{
	u8 CmdBuf[] = {0xFC, 0xF3, 0x3B, 0xFF, 0xFF, 0xFF, 0xFF};

	CmdBuf[3] = (addr & 0xFF00) >> 8;
	CmdBuf[4] = addr & 0xFF;
	CmdBuf[5] = (value & 0xFF00) >> 8;
	CmdBuf[6] = value & 0xFF;

	if(sizeof(CmdBuf) != i2c_master_send(client, CmdBuf, sizeof(CmdBuf))) {
		#if FM34_DEBUG
		printk(KERN_DEBUG "WriteFM34Register Addr:0x%02X%02X Data:0x%02X%02X failed\n", CmdBuf[3], CmdBuf[4], CmdBuf[5], CmdBuf[6]);
		#endif
		return -1;
	} else {
		#if FM34_DEBUG
		printk(KERN_DEBUG "WriteFM34Register Addr:0x%02X%02X Data:0x%02X%02X successful\n", CmdBuf[3], CmdBuf[4], CmdBuf[5], CmdBuf[6]);
		#endif
		return 0;
	}
}

bool set_fM34_bypass(void)
{
	int *fm34_pwr = fm34_client->dev.platform_data;
	struct fm34_drvdata *pfm34_drvdata = platform_get_drvdata(fm34_client);

	#if FM34_DEBUG
	printk(KERN_INFO "set_fM34_bypass\n");
	#endif

	if(pfm34_drvdata->fm34_status) {
		fm34_register_write(fm34_client, 0x2300, 0x0004);
		msleep(15);
		gpio_direction_output(*fm34_pwr, 0);
		pfm34_drvdata->fm34_status = 0;
	}

	return 1;
}
EXPORT_SYMBOL(set_fM34_bypass);

bool set_fM34_echo(void)
{
	int *fm34_pwr = fm34_client->dev.platform_data;
	struct fm34_drvdata *pfm34_drvdata = platform_get_drvdata(fm34_client);

	if(!pfm34_drvdata->fm34_enable_status) {
		#if FM34_DEBUG
		printk(KERN_INFO "cancel set_fM34_echo\n");
		#endif
		return 0;
	}

	#if FM34_DEBUG
	printk(KERN_INFO "set_fM34_echo\n");
	#endif
	if(0 == pfm34_drvdata->fm34_status) {
		gpio_direction_output(*fm34_pwr, 1);
		msleep(15);
		fm34_register_write(fm34_client, 0x2300, 0x0000);
		pfm34_drvdata->fm34_status = 1;
	}

	return 1;
}
EXPORT_SYMBOL(set_fM34_echo);

bool get_fM34_status(void)
{
	struct fm34_drvdata *pfm34_drvdata = platform_get_drvdata(fm34_client);

	return pfm34_drvdata->fm34_status;
}
EXPORT_SYMBOL(get_fM34_status);

static bool set_fm34_patch(struct i2c_client *client)
{
	u16 index;

	#if FM34_DEBUG
	printk(KERN_DEBUG "set_fm34_patch\n");
	#endif

	for(index=0;index<sizeof(patch_data)/sizeof(u8)/9;index++) {
		i2c_master_send(client, &patch_data[index][1], patch_data[index][0]);
	}

	return 1;
}

static bool set_fm34_prop(struct i2c_client *client)
{
	u16 index;
	u16 CmdBuf[][2] = {
	{0x22F8, 0x8005},
	{0x22E3, 0x50C2},
	{0x22C8, 0x0009},
	{0x22EE, 0x0000},
	{0x22F9, 0x085F},
	{0x22FA, 0x248B},
	{0x2305, 0x0004},
	{0x2301, 0x0001},
	{0x2303, 0x2D81},
	{0x236E, 0x7FFF},
	{0x2307, 0xF8F8},	// Entry MIC in Gain
	{0x2309, 0x0800},
	{0x230D, 0x0100},	// Speaker Out Gain
	{0x230C, 0x1000},	// Leave MIC In Gain
	{0x2310, 0x1880},
	{0x232F, 0x0080},
	{0x22F2, 0x0040},
	{0x2357, 0x0100},
	{0x22F6, 0x0000},
	{0x22C6, 0x0031},
	{0x22C7, 0x0050},
	{0x22D2, 0x8294},
	{0x23D7, 0x002A},
	{0x23E0, 0x4000},
	{0x23E1, 0x4000},
	{0x23E2, 0x4000},
	{0x23E3, 0x4000},
	{0x23E4, 0x4000},
	{0x22FB, 0x0000}};

	#if FM34_DEBUG
	printk(KERN_DEBUG "set_fm34_prop\n");
	#endif

	for(index=0;index<sizeof(CmdBuf)/sizeof(u16)/2;index++) {
		fm34_register_write(client, CmdBuf[index][0], CmdBuf[index][1]);
	}

	return 1;
}

ssize_t fm34_enable_sotre(struct device *dev,
	struct device_attribute *attr, const char *buf, size_t len)
{
	struct fm34_drvdata *pfm34_drvdata = platform_get_drvdata(fm34_client);

	if(len != 2){
		return -EINVAL;
	}

	if(buf[0] == '0')
		pfm34_drvdata->fm34_enable_status = 0;
	else
		pfm34_drvdata->fm34_enable_status = 1;

	return len;
}

ssize_t fm34_enable_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct fm34_drvdata *pfm34_drvdata = platform_get_drvdata(fm34_client);

	sprintf(buf, "%s\n", pfm34_drvdata->fm34_enable_status ? "1" : "0");
	return strlen(buf);
}
DEVICE_ATTR(fm34_enable, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, fm34_enable_show, fm34_enable_sotre);

static int __devinit fm34_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	int *fm34_pwr = client->dev.platform_data;
	struct fm34_drvdata *pfm34_drvdata;
	struct clk *dap_mclk;
	u16 sysReady;
	int err;

	fm34_client = client;

	pfm34_drvdata = kzalloc(sizeof(struct fm34_drvdata), GFP_KERNEL);
	if (pfm34_drvdata == NULL)
		return -ENOMEM;
	pfm34_drvdata->fm34_enable_status = 1;
	pfm34_drvdata->fm34_status = 1;
	platform_set_drvdata(fm34_client, pfm34_drvdata);

	dap_mclk = i2s_get_clock_by_name("clk_dev1");
	if (!dap_mclk) {
		pr_err("%s: could not get DAP clock\n", __func__);
		kfree(pfm34_drvdata);
		return -EIO;
	}
	clk_enable(dap_mclk);

	err = gpio_request(*fm34_pwr, client->name);
	if (err < 0) {
		pr_err("%s: failed to request GPIO %d,"
			" error %d\n", __FUNCTION__, *fm34_pwr, err);
		goto gpio_fail;
	}

	gpio_direction_output(*fm34_pwr, 1);
	msleep(15);
	err = fm34_register_read(client, 0x22FB, &sysReady);
	if (err < 0) {
		pr_err("%s: dsp probe failed\n", __FUNCTION__);
		goto pwr_gpio_fail;
	}

	if(sysReady != 0x5A5A) {
		set_fm34_patch(client);
		set_fm34_prop(client);
		msleep(250);
		fm34_register_read(client, 0x22FB, &sysReady);
		if(sysReady != 0x5A5A) {
			err = -EFAULT;
			goto pwr_gpio_fail;
		}
	}
	set_fM34_bypass();

	err = device_create_file(&client->dev, &dev_attr_fm34_enable);
	if (err) {
		pr_err("%s: add_sysfs_entry enable failed\n", __FUNCTION__);
	}

	printk(KERN_INFO "%s successfully registered\n", client->driver->driver.name);
	return err;

pwr_gpio_fail:
	gpio_free(*fm34_pwr);
gpio_fail:
	tegra_das_power_mode(false);

	return err;
}

static int __devexit fm34_i2c_remove(struct i2c_client *client)
{
	int *fm34_pwr = client->dev.platform_data;
	struct fm34_drvdata *pfm34_drvdata;

	pfm34_drvdata = platform_get_drvdata(client);
	kfree(pfm34_drvdata);

	gpio_free(*fm34_pwr);
	return 0;
}

static const struct i2c_device_id fm34_i2c_id[] = {
	{ DRIVER_NAME, 0 },
	{ }
};

static struct i2c_driver fm34_i2c_driver = {
    .probe   = fm34_i2c_probe,
    .remove  = fm34_i2c_remove,
	.id_table	= fm34_i2c_id,
    .driver  = {
        .name   = "FM34",
    },
};

static int __init fm34_i2c_init(void) {
    int e;

	e = i2c_add_driver(&fm34_i2c_driver);
	if (e != 0) {
		pr_err("%s: failed to register with I2C bus with "
		       "error: 0x%x\n", __func__, e);
	}
	return e;
}

static void __exit fm34_i2c_exit(void) {

    i2c_del_driver(&fm34_i2c_driver);
}

module_init(fm34_i2c_init);
module_exit(fm34_i2c_exit);

MODULE_DESCRIPTION("Fortemedia I2C echo cancellation driver");

